#!/usr/bin/stap

############################################################
# Schedtimes.stp
# Author: Jason Baron <jbaron@redhat.com>
# profiles threads and displays their run times, queued times,
# wait times, including i/o wait times.
# Has two modes. When no arguments are given it profiles all
# threads. Alternatively, you can pass -c "program name"
############################################################

//constants
global RUNNING=0, QUEUED=1, SLEEPING=2

global run_time, queued_time,  sleep_time, io_wait_time, tgid_run_time
global pid_state, pid_names, pid_parent, pid_parent_names, pid_rparent_names, pid_tgid
global previous_timestamp
global io_wait_count
global io_wait_incremented

function get_iowait:long(queue:long)
{
  return @cast(queue,"rq","kernel")->nr_iowait->counter;
}

probe kernel.trace("sched_switch") {
  previous_pid = $prev->pid;
  previous_tgid = $prev->tgid;
  next_pid = $next->pid;
  if (previous_pid) {
    if (!([previous_pid] in pid_state)) {
      //use this state as entry into state machine
      previous_timestamp[previous_pid] = gettimeofday_us();
      pid_names[previous_pid] = kernel_string($prev->comm);
      if ($prev->state > 0) {
        pid_state[previous_pid] = SLEEPING;
      } else if ($prev->state == 0) {
        pid_state[previous_pid] = QUEUED;
      } else {
#        printf("unknown transition:\n");
#        printf("pid state: %d our state: %d\n",
#          $prev->state, pid_state[previous_pid]);
      }
    } else if (pid_state[previous_pid] == RUNNING) {
      pid_names[previous_pid] = kernel_string($prev->comm);
      t = gettimeofday_us();  
      run_time[previous_pid] += (t - previous_timestamp[previous_pid]);
      tgid_run_time[previous_tgid] += (t - previous_timestamp[previous_pid]);
      previous_timestamp[previous_pid] = t;
      if ($prev->state > 0) {
        if ((get_iowait($rq) - io_wait_count[previous_pid]) > 0)
          io_wait_incremented[previous_pid] = 1;  
        pid_state[previous_pid] = SLEEPING;
      } else if ($prev->state == 0) {
        pid_state[previous_pid] = QUEUED;
      } else {
#        printf("unknown transition:\n");
#        printf("pid state: %d our state: %d\n",
#          $prev->state, pid_state[previous_pid]);
      }
    } else {
 #     printf("unknown transition:\n");
 #     printf("%s pid state: %d our state: %d\n",
 #          pid_names[previous_pid],
 #          $prev->state, pid_state[previous_pid]);
    }
  }
  if (next_pid) {
    io_wait_count[next_pid] = get_iowait($rq);
    if (!([next_pid] in pid_state)) {
      //use this state as entry into state machine
      previous_timestamp[next_pid] =  gettimeofday_us();
      pid_state[next_pid] = RUNNING;
      pid_names[next_pid] = kernel_string($next->comm);
    } else if (pid_state[next_pid] == QUEUED) {
      t = gettimeofday_us();
      queued_time[next_pid] += (t - previous_timestamp[next_pid]);
      previous_timestamp[next_pid] = t;
      pid_state[next_pid] = RUNNING;
      pid_names[next_pid] = kernel_string($next->comm);
    } else {
      printf("unknown transition:\n");
      printf("%s pid state: %d our state: %d\n",
        pid_names[next_pid],
        $next->state, pid_state[next_pid]);
    }
  }
}

probe kernel.trace("sched_wakeup") {
  wakeup_pid = $p->pid;
  if ((!$success) && (pid_state[wakeup_pid] != SLEEPING)) next
  if (!wakeup_pid) next
  pid_parent[wakeup_pid] = $p->parent->pid;
      pid_tgid[wakeup_pid] = $p->tgid;
      pid_parent_names[wakeup_pid] = kernel_string($p->parent->comm);
      pid_rparent_names[wakeup_pid] = kernel_string($p->real_parent->comm);

  if (!([wakeup_pid] in pid_state)) {
    //use this state as entry into state machine
    previous_timestamp[wakeup_pid] =  gettimeofday_us();
    pid_state[wakeup_pid] = QUEUED;
    pid_names[wakeup_pid] = kernel_string($p->comm);
  } else if (pid_state[wakeup_pid] == SLEEPING) {
    t = gettimeofday_us();
    sleep_time[wakeup_pid] += (t - previous_timestamp[wakeup_pid]);
    if (io_wait_incremented[wakeup_pid] == 1) {
      io_wait_time[wakeup_pid] += (t - previous_timestamp[wakeup_pid]);
      io_wait_incremented[wakeup_pid] = 0;
    }
    previous_timestamp[wakeup_pid] = t;
    pid_state[wakeup_pid] = QUEUED;
    pid_names[wakeup_pid] = kernel_string($p->comm);
  } else {
#    printf("unknown transition:\n");
#    printf("pid state: %d our state: %d\n",
#      $p->state, pid_state[wakeup_pid]);
  }
}

probe timer.ms(1000) {
# times are stored in microseconds
#pid_by_name = [];
#tgid_run_time=[];
  #    foreach (pid+ in run_time) {
 #     	      if (!(pid_tgid[pid] in tgid_run_time)) {
#	      	 tgid_run_time[pid_tgid[pid]] = 0;
#	      }
#	      tgid_run_time[pid_tgid[pid]] += run_time[pid];
#	      run_time[pid] = 0;
#      }
  t = gettimeofday_us();
  printf("%d\n", t);
  
#      printf ("plot ");
#      foreach (tgid in tgid_run_time) {
#      	      printf ("'-' title \"%d\" with lines,", tgid);
#      }
#      printf ("\n");
      foreach (tgid in tgid_run_time) {
	if (pid_names[tgid] != "") {
      	      printf ("usage:%\s:%d\n", pid_names[tgid], tgid_run_time[tgid]);
}
      }
  printf("\n");
}

probe begin {
  printf("%d\n", gettimeofday_us());
  printf("CPU Usage\n"); # script name
  printf("usage:0:100:0\n"); # script name
  printf("\n");
}

probe end {
  t = gettimeofday_us();
  foreach (pid in pid_state) {
    if (pid_state[pid] == SLEEPING)
      sleep_time[pid] += (t - previous_timestamp[pid]);
    if (pid_state[pid] == QUEUED)
      queued_time[pid] += (t - previous_timestamp[pid]);
    if (pid_state[pid] == RUNNING)
      run_time[pid] += (t - previous_timestamp[pid]);
  }
  printf ("%16s: %6s %10s %10s %10s %10s %10s %10s %10s %10s\n\n",
         "execname", "pid", "pname",  "rpname", "realparent", "run(us)", "sleep(us)", "io_wait(us)",
         "queued(us)", "total(us)")
  foreach (pid+ in run_time) {
    printf("%16s: %6d %16s %16s %10d %10d %10d %10d %10d %10d\n", 
      pid_names[pid], pid, pid_parent_names[pid],pid_rparent_names[pid], pid_parent[pid], run_time[pid], sleep_time[pid], 
      io_wait_time[pid], pid_tgid[pid],
      (run_time[pid] + sleep_time[pid] + queued_time[pid]));
  }
}
